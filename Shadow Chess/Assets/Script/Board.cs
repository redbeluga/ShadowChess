using System;using System.Collections.Generic;using FishNet.Object;using Unity.VisualScripting;using UnityEngine;using Random = UnityEngine.Random;public class Board : NetworkBehaviour{    public static Board Instance { get; private set; }    [SerializeField] private bool whiteMove = true;    [SerializeField] private bool whiteKingCheckmate = false;    [SerializeField] private bool blackKingCheckmate = false;    [SerializeField] public GameObject blackPawn, blackKnight, blackRook, blackBishop, blackQueen, blackKing;    [SerializeField] public GameObject whitePawn, whiteKnight, whiteRook, whiteBishop, whiteQueen, whiteKing;    [SerializeField] public List<Player> players;    private bool localIsWhite;    private bool[,] controlledBoard = new bool[8, 8];    [SerializeField] private GameObject darkCover;    [SerializeField] private GameObject lightCover;    [SerializeField] private GameObject[] boardCovers = new GameObject[64];    public bool GameOver;    public bool LocalIsWhite    {        get => localIsWhite;        set => localIsWhite = value;    }    private List<GameObject> activeWhitePieces, activeBlackPieces, inActiveWhitePieces, inActiveBlackPieces;    private Vector3 topLeft, bottomRight;    private float length, gridLength;    private Vector3[,] gridCenterLocation = new Vector3[8, 8];    private GameObject[,] filledBoard = new GameObject[8, 8];    public bool WhiteMove    {        get => whiteMove;        set => whiteMove = value;    }    public GameObject[,] FilledBoard    {        get => filledBoard;        set => filledBoard = value;    }    void Awake()    {        Instance = this;        // Get the SpriteRenderer component attached to the GameObject        SpriteRenderer spriteRenderer = GetComponent<SpriteRenderer>();        activeWhitePieces = new List<GameObject>();        activeBlackPieces = new List<GameObject>();        inActiveWhitePieces = new List<GameObject>();        inActiveBlackPieces = new List<GameObject>();        // Get the bounds of the sprite in world space        Bounds spriteBounds = spriteRenderer.bounds;        // Calculate the top-right and bottom-left corners        topLeft = new Vector3(spriteBounds.min.x, spriteBounds.max.y, spriteBounds.center.z);        bottomRight = new Vector3(spriteBounds.max.x, spriteBounds.min.y, spriteBounds.center.z);        length = bottomRight.x - topLeft.x;        gridLength = length / 8;        for (int i = 0; i < 8; i++)        {            for (int j = 0; j < 8; j++)            {                gridCenterLocation[i, j] = new Vector3(topLeft.x + (i + 0.5f) * gridLength,                    topLeft.y - (j + 0.5f) * gridLength, spriteBounds.center.x);            }        }        spriteRenderer.enabled = false;    }    // private void OnDrawGizmos()    // {    //     // if (Application.isPlaying)    //     // {    //     //     for (int i = 0; i < 8; i++)    //     //     {    //     //         for (int j = 0; j < 8; j++)    //     //         {    //     //             Vector2Int gridPos = new Vector2Int(i, j);    //     //             bool control = SpotUnderControl(gridPos);    //     //             Gizmos.color = Color.red;    //     //             if (control) Gizmos.color = localIsWhite ? Color.white : Color.black;    //     //                 //     //             Vector2Int correctedPos = OutputCorrectLocation(gridPos, localIsWhite);    //     //             Gizmos.DrawWireSphere(CenterOfSquare(correctedPos), 0.2f);    //     //         }    //     //     }    //     // }    // }    private void OnDisable()    {        GetComponent<SpriteRenderer>().enabled = false;    }    [ServerRpc(RequireOwnership = false)]    public void CreateBoardCover()    {        for (int i = 0; i < 8; i++)        {            for (int j = 0; j < 8; j++)            {                GameObject newCover = Instantiate((i + j) % 2 == 0 ? lightCover : darkCover,                    CenterOfSquare(new Vector2Int(i, j)), Quaternion.identity);                ServerManager.Spawn(newCover);                LocalCreateBoardCover(newCover, i * 8 + j);            }        }    }    [ObserversRpc]    public void LocalUpdateVision(bool white)    {        if (localIsWhite == white)        {            for (int i = 0; i < 8; i++)            {                for (int j = 0; j < 8; j++)                {                    Vector2Int correctLoc = OutputCorrectLocation(new Vector2Int(i, j), localIsWhite);                    if (controlledBoard[i, j]) boardCovers[correctLoc.x * 8 + correctLoc.y].SetActive(false);                    else boardCovers[correctLoc.x * 8 + correctLoc.y].SetActive(true);                }            }        }    }    [ObserversRpc]    public void LocalCreateBoardCover(GameObject newCover, int loc)    {        // Debug.Log("ASSIGNING COVERS");        boardCovers[loc] = newCover;        boardCovers[loc].SetActive(false);    }    public void Spawn32Pieces()    {        for (int i = 0; i < 8; i++)        {            ServerCreateChessPiece(whitePawn, new Vector2Int(i, 6));        }        ServerCreateChessPiece(whiteKing, new Vector2Int(4, 7));        ServerCreateChessPiece(whiteRook, new Vector2Int(0, 7));        ServerCreateChessPiece(whiteRook, new Vector2Int(7, 7));        ServerCreateChessPiece(whiteKnight, new Vector2Int(1, 7));        ServerCreateChessPiece(whiteKnight, new Vector2Int(6, 7));        ServerCreateChessPiece(whiteBishop, new Vector2Int(2, 7));        ServerCreateChessPiece(whiteBishop, new Vector2Int(5, 7));        ServerCreateChessPiece(whiteQueen, new Vector2Int(3, 7));        for (int i = 0; i < 8; i++)        {            ServerCreateChessPiece(blackPawn, new Vector2Int(i, 1));        }        ServerCreateChessPiece(blackKing, new Vector2Int(4, 0));        ServerCreateChessPiece(blackRook, new Vector2Int(0, 0));        ServerCreateChessPiece(blackRook, new Vector2Int(7, 0));        ServerCreateChessPiece(blackKnight, new Vector2Int(1, 0));        ServerCreateChessPiece(blackKnight, new Vector2Int(6, 0));        ServerCreateChessPiece(blackBishop, new Vector2Int(2, 0));        ServerCreateChessPiece(blackBishop, new Vector2Int(5, 0));        ServerCreateChessPiece(blackQueen, new Vector2Int(3, 0));    }    // Helper functions    public bool EmptySpotOnBoard(Vector2Int loc)    {        return FilledBoard[loc.x, loc.y] == null;    }    public static bool LocInBounds(Vector2Int newLoc)    {        return (newLoc.x >= 0 && newLoc.x <= 7 && newLoc.y >= 0 && newLoc.y <= 7);    }    public Vector2Int FindClickedSquare(Vector2 mousePosition)    {        float closestDistance = Mathf.Infinity;        Vector2Int clickedLoc = Vector2Int.zero;        if (mousePosition.y < bottomRight.y || mousePosition.y > topLeft.y || mousePosition.x > bottomRight.x ||            mousePosition.x < topLeft.x)        {            return new Vector2Int(-1, -1);        }        for (int i = 0; i < 8; i++)        {            for (int j = 0; j < 8; j++)            {                float distance = Vector3.Distance(mousePosition, gridCenterLocation[i, j]);                if (distance < closestDistance)                {                    closestDistance = distance;                    clickedLoc = new Vector2Int(i, j);                }            }        }        return clickedLoc;    }    public bool AllEmptySpacesBetween(ChessPiece A, ChessPiece B)    {        int minX = Mathf.Min(A.CurLoc.x, B.CurLoc.x);        int minY = Mathf.Min(A.CurLoc.y, B.CurLoc.y);        int maxX = Mathf.Max(A.CurLoc.x, B.CurLoc.x);        int maxY = Mathf.Max(A.CurLoc.y, B.CurLoc.y);        int dx = (maxX - minX) == 0 ? 0 : (int)Mathf.Sign(maxX - minX);        int dy = (maxY - minY) == 0 ? 0 : (int)Mathf.Sign(maxY - minY);        Debug.Log(minX + " " + minY + " " + maxX + " " + maxY);        for (int x = minX + dx, y = minY + dy; x < maxX || y < maxY; x += dx, y += dy)        {            Debug.Log(x + " " + y);            if (!EmptySpotOnBoard(new Vector2Int(x, y))) return false;        }        return true;    }    public Vector2 CenterOfSquare(Vector2Int clickedSquare)    {        return gridCenterLocation[clickedSquare.x, clickedSquare.y];    }    public bool SpotUnderControl(Vector2Int loc)    {        return controlledBoard[loc.x, loc.y];    }    // Functions called at start of game    public void AddPlayer(Player p)    {        players.Add(p);        if (players.Count == 2)        {            AssignSides();            Spawn32Pieces();            CreateBoardCover();            SweepControl(true);            SweepControl(false);            ShowBoard();        }    }    [ServerRpc(RequireOwnership = false)]    public void ShowBoard()    {        LocalUpdateVision(true);        LocalUpdateVision(false);        foreach (GameObject chessPiece in activeWhitePieces)        {            LocalEnableChessPieceSprite(chessPiece.GetComponent<ChessPiece>());        }        foreach (GameObject chessPiece in activeBlackPieces)        {            LocalEnableChessPieceSprite(chessPiece.GetComponent<ChessPiece>());        }        LocalSetBoardSpriteRendererVisibility(true);        LocalShowInGameUI();    }    [ObserversRpc]    private void LocalShowInGameUI()    {        string playerName = LobbyManager.Instance.PlayerName;        string opponentName =            (LobbyManager.Instance.CurrentLobby.Players.Find((p) =>                p.Data[LobbyManager.k_playerName].Value != playerName)).Data[LobbyManager.k_playerName].Value;        InGameUI.Instance.Show(playerName, opponentName, localIsWhite);    }    private void AssignSides()    {        float randVal = Random.value;        if (randVal > 0.5)        {            (players[0], players[1]) = (players[1], players[0]);        }        players[0].GetComponent<Player>().SetWhite(true, players[0]);        players[1].GetComponent<Player>().SetWhite(false, players[1]);    }    [ServerRpc(RequireOwnership = false)]    public void ServerCreateChessPiece(GameObject chessPiece, Vector2Int loc)    {        GameObject newChessPiece = Instantiate(chessPiece, Vector2.zero, Quaternion.identity);        ServerManager.Spawn(newChessPiece);        ChessPiece newChessPieceScript = newChessPiece.GetComponent<ChessPiece>();        FilledBoard[loc.x, loc.y] = newChessPiece;        // filledBoardNames[loc.x, loc.y] = newChessPiece.gameObject.name;        newChessPieceScript.CurLoc = loc;        if (newChessPieceScript.IsWhite)        {            activeWhitePieces.Add(newChessPiece);            newChessPieceScript.Player = players[0];            players[0].GetComponent<Player>().AddChessPiece(newChessPiece);        }        else        {            activeBlackPieces.Add(newChessPiece);            newChessPieceScript.Player = players[1];            players[1].GetComponent<Player>().AddChessPiece(newChessPiece);        }        newChessPieceScript.OnCreate();        FilledBoard[newChessPieceScript.CurLoc.x, newChessPieceScript.CurLoc.y] = null;        // FilledBoardNames[activeChessPiece.CurLoc.x, activeChessPiece.CurLoc.y] = null;        FilledBoard[loc.x, loc.y] = newChessPieceScript.gameObject;        // FilledBoardNames[gridLoc.x, gridLoc.y] = activeChessPiece.gameObject.name;        newChessPieceScript.CurLoc = loc;        if (newChessPieceScript is King)        {            ((King)newChessPieceScript).UpdateLoc();        }        ClientMovePiece(newChessPieceScript, loc);    }    [ObserversRpc]    public void LocalDisablePiece(GameObject disabledChessPiece)    {        disabledChessPiece.SetActive(false);    }    [ObserversRpc]    public void LocalEnableChessPieceSprite(ChessPiece enabledChessPiece)    {        enabledChessPiece.EnableSprite();    }    [ObserversRpc]    public void LocalSetBoardSpriteRendererVisibility(bool on)    {        GetComponent<SpriteRenderer>().enabled = on;    }    // Moving pieces    [ServerRpc(RequireOwnership = false)]    public void ServerMovePiece(ChessPiece activeChessPiece, Vector2Int gridLoc)    {        // Debug.Log(gridLoc);        FilledBoard[activeChessPiece.CurLoc.x, activeChessPiece.CurLoc.y] = null;        // FilledBoardNames[activeChessPiece.CurLoc.x, activeChessPiece.CurLoc.y] = null;        FilledBoard[gridLoc.x, gridLoc.y] = activeChessPiece.gameObject;        // FilledBoardNames[gridLoc.x, gridLoc.y] = activeChessPiece.gameObject.name;        activeChessPiece.CurLoc = gridLoc;        if (activeChessPiece is King)        {            ((King)activeChessPiece).UpdateLoc();        }        ClientMovePiece(activeChessPiece, gridLoc);    }    [ObserversRpc]    public void ClientMovePiece(ChessPiece activeChessPiece, Vector2Int gridLoc)    {        Vector2 loc = CenterOfSquare(OutputCorrectLocation(gridLoc, localIsWhite));        activeChessPiece.transform.position = loc;    }    [ServerRpc(RequireOwnership = false)]    public void ServerPostMoveHandling()    {        whiteMove = !whiteMove;        LocalChangeMoveDisplay(whiteMove);        SweepControl(true);        SweepControl(false);    }    [ObserversRpc]    private void LocalChangeMoveDisplay(bool whiteMove)    {        InGameUI.Instance.ChangeTurns(localIsWhite == whiteMove);    }    [ServerRpc(RequireOwnership = false)]    public void TakePiece(Vector2Int locToTake)    {        GameObject takenChessPiece = FilledBoard[locToTake.x, locToTake.y];        bool takenPieceIsWhite = takenChessPiece.GetComponent<ChessPiece>().IsWhite;        if (takenPieceIsWhite)        {            // Debug.Log("REmove");            activeWhitePieces.Remove(takenChessPiece);            inActiveWhitePieces.Add(takenChessPiece);        }        else        {            // Debug.Log("REmove");            activeBlackPieces.Remove(takenChessPiece);            inActiveBlackPieces.Add(takenChessPiece);        }        if (takenChessPiece.GetComponent<ChessPiece>() is King)        {            if (takenPieceIsWhite)            {                whiteKingCheckmate = true;            }            else            {                blackKingCheckmate = true;            }            OnGameOver(!takenPieceIsWhite, "By checkmate");        }        takenChessPiece.GetComponent<ChessPiece>().onDisable();        LocalTakePiece(takenChessPiece, takenPieceIsWhite);        LocalDisablePiece(takenChessPiece);    }    [ObserversRpc]    private void LocalTakePiece(GameObject takenChessPiece, bool takenPieceIsWhite)    {        Debug.Log("Hey");        InGameUI.Instance.TakePiece(takenChessPiece, takenPieceIsWhite);    }    [ObserversRpc]    private void OnGameOver(bool winner, string reason)    {        if (winner) blackKingCheckmate = true;        else whiteKingCheckmate = true;        GameOver = true;        LocalGameManager.Instance.GameOver(winner, reason);    }    public void CastleKing(ChessPiece kingPiece, ChessPiece rookPiece, Vector2Int kingNewLoc, Vector2Int rookNewloc)    {        ServerMovePiece(kingPiece, kingNewLoc);        ServerMovePiece(rookPiece, rookNewloc);    }    [ServerRpc(RequireOwnership = false)]    public void SweepControl(bool white) // for vision    {        List<GameObject> activePieces =            white ? new List<GameObject>(activeWhitePieces) : new List<GameObject>(activeBlackPieces);        // Debug.Log("Sweeping " + (white ? "white" : "black"));        bool[] sweptControlledBoard = new bool[64];        foreach (GameObject piece in activePieces)        {            ChessPiece pieceScript = piece.GetComponent<ChessPiece>();            sweptControlledBoard[pieceScript.CurLoc.x * 8 + pieceScript.CurLoc.y] = true;            foreach (Vector2Int newLoc in pieceScript.GetControlledSpots())            {                sweptControlledBoard[newLoc.x * 8 + newLoc.y] = true;                // Debug.Log(newLoc);            }        }        LocalSweepControl(white, sweptControlledBoard);        LocalUpdateVision(white);    }    [ObserversRpc]    public void LocalSweepControl(bool white, bool[] sweptControlBoard) // for vision    {        if (localIsWhite == white)        {            for (int i = 0; i < 8; i++)            {                for (int j = 0; j < 8; j++)                {                    controlledBoard[i, j] = sweptControlBoard[i * 8 + j];                }            }        }    }    public Vector2Int OutputCorrectLocation(Vector2Int input, bool white)    {        if (white)        {            return input;        }        return new Vector2Int(7, 7) - input;    }}